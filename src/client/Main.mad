import type { WebSocket } from "MadWebSocketClient"

import ByteArray from "ByteArray"
import IO from "IO"
import List from "List"
import Math from "Math"
import Maybe from "Maybe"
import Process from "Process"
import String from "String"
import Terminal from "Terminal"

import WebSocket from "MadWebSocketClient"

import { getSubnetIpRange } from "@/client/IP"
import {
  eraseAfterCursor,
  registerKeyPress,
  restoreCursor,
  saveCursor,
  setTimeout,
} from "@/client/Misc"
import {
  MessageEvent,
  RegisteredEvent,
  UserJoinedEvent,
  UserLeftEvent,
  parseEvent,
} from "@/common/Event"
import { printMessageEvent } from "@/common/Message"
import { printSignInEvent } from "@/common/SignIn"



makeBuffer :: {}
  -> { get :: {} -> String, pop :: {} -> {}, push :: String -> {}, reset :: {} -> {} }
makeBuffer = () => {
  data = ""

  return {
    push: (char) => {
      data = data ++ char
    },
    get: () => data,
    reset: () => {
      data = ""
    },
    pop: () => {
      data = String.dropLast(1, data)
    },
  }
}

buffer = makeBuffer()

loop :: WebSocket -> String -> Integer -> {}
loop = (ws, author, userId) => {
  saveCursor()
  IO.put("> ")
  registerKeyPress(
    (char) => {
      if (char == "\r") do {
        if (buffer.get() != "") do {
          WebSocket.send(
            ByteArray.fromString(
              printMessageEvent({
                eventType: "MESSAGE",
                author,
                content: buffer.get(),
                authorId: userId,
              }),
            ),
            ws,
          )
          buffer.reset()
        }
      } else {
        if (char == "\x03") do { Process.exit(0) } else {
          if (char == "\x7F") do {
            buffer.pop()
            restoreCursor()
            eraseAfterCursor()
            IO.put("> ")
            IO.put(buffer.get())
          } else {
            if (char == "\x1B[A" || char == "\x1B[B" || char == "\x1B[C" || char == "\x1B[D") {
              {}
            } else do {
              IO.put(char)
              buffer.push(char)
            }
          }
        }
      }
    },
  )
}


AVAILABLE_COLORS :: List (String -> String)
AVAILABLE_COLORS = [
  Terminal.text.brightCyan,
  Terminal.text.brightRed,
  Terminal.text.brightYellow,
  Terminal.text.brightGreen,
  Terminal.text.brightMagenta,
  Terminal.text.brightBlue,
]


pickColorById :: Integer -> String -> String
pickColorById = (id) => pipe(
  List.length,
  Math.mod(id),
  List.nth($, AVAILABLE_COLORS),
  Maybe.fromMaybe(Terminal.text.brightCyan),
)(AVAILABLE_COLORS)





tryUrls :: String -> List String -> {}
tryUrls = (name, urls) => where(urls) {
  [url, ...next] =>
    do {
      hasFailed = false
      hasConnected = false
      ws = WebSocket.connect(url)

      setTimeout(() => { if (!hasConnected) { WebSocket.disconnect(ws) } }, 50)

      WebSocket.onError(
        pipe(
          .code,
          (code) => {
            if (
              code
                == "ECONNREFUSED"
                || code
                == "EACCES"
                || code
                == "ETIMEDOUT"
                || code
                == "EHOSTDOWN"
                || code
                == "EHOSTUNREACH"
                || code
                == #- undefined -#
            ) do {
              hasFailed = true
              tryUrls(name, next)
            } else { IO.errLine(code) }
          },
        ),
        ws,
      )
      WebSocket.onConnected(
        () => {
          hasConnected = true
          pipe(
            (pseudo) => ({ pseudo, eventType: "SIGN_IN" }),
            printSignInEvent,
            ByteArray.fromString,
            WebSocket.send($, ws),
          )(name)
        },
        ws,
      )
      WebSocket.onDisconnected(() => { if (!hasFailed) { IO.putLine("Connection lost") } }, ws)
      WebSocket.onMessage(
        pipe(
          ByteArray.toString,
          parseEvent,
          where {
            RegisteredEvent({ userId }) =>
              do {
                IO.putLine(Terminal.text.brightBlack("You are connected!"))
                loop(ws, name, userId)
              }

            MessageEvent({ author, authorId, content }) =>
              do {
                colorFn = pickColorById(authorId)
                restoreCursor()
                IO.putLine(`${colorFn(author)}: ${content}`)
                saveCursor()
                IO.put("> ")
                IO.put(buffer.get())
              }

            UserJoinedEvent({ author, userId }) =>
              do {
                colorFn = pickColorById(userId)
                restoreCursor()
                IO.putLine(`${colorFn(author)} ${Terminal.text.brightBlack("joined the chatroom")}`)
                saveCursor()
                IO.put("> ")
                IO.put(buffer.get())
              }

            UserLeftEvent({ author, userId }) =>
              do {
                colorFn = pickColorById(userId)
                restoreCursor()
                IO.putLine(`${colorFn(author)} ${Terminal.text.brightBlack("left the chatroom")}`)
                saveCursor()
                IO.put("> ")
                IO.put(buffer.get())
              }

            _ =>
              {}
          },
        ),
        ws,
      )
    }

  [] =>
    IO.errLine("No server found")
}


main = (args) => {
  where(args) {
    [_, name] =>
      do {
        IO.putLine(Terminal.text.brightBlack("Looking for a server.."))
        pipe(
          map((ip) => `ws://${ip}:3000/path`),
          tryUrls(name),
        )(getSubnetIpRange())
      }

    _ =>
      IO.errLine("Bad input")
  }
}
